"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchTransport = exports.removeTrailingUndefs = exports.createRequest = exports.rpcClient = exports.RpcError = void 0;
/**
 * Error class that is thrown if a remote method returns an error.
 */
class RpcError extends Error {
    constructor(message, code, data) {
        super(message);
        this.code = code;
        this.data = data;
        // https://www.typescriptlang.org/docs/handbook/2/classes.html#inheriting-built-in-types
        Object.setPrototypeOf(this, RpcError.prototype);
    }
}
exports.RpcError = RpcError;
function rpcClient(options) {
    if (typeof options === "string") {
        options = { url: options };
    }
    const transport = "transport" in options ? options.transport : fetchTransport(options);
    /**
     * Send a request using the configured transport and handle the result.
     */
    const sendRequest = async (method, args, signal) => {
        const res = await transport(createRequest(method, args), signal);
        if ("result" in res) {
            return res.result;
        }
        else if ("error" in res) {
            const { code, message, data } = res.error;
            throw new RpcError(message, code, data);
        }
        throw new TypeError("Invalid response");
    };
    // Map of AbortControllers to abort pending requests
    const abortControllers = new WeakMap();
    const target = {
        /**
         * Abort the request for the given promise.
         */
        $abort: (promise) => {
            const ac = abortControllers.get(promise);
            ac?.abort();
        },
    };
    return new Proxy(target, {
        /* istanbul ignore next */
        get(target, prop, receiver) {
            if (typeof prop === "symbol")
                return;
            if (prop in Object.prototype)
                return;
            if (prop === "toJSON")
                return;
            if (Reflect.has(target, prop)) {
                return Reflect.get(target, prop, receiver);
            }
            if (prop.startsWith("$"))
                return;
            return (...args) => {
                const ac = new AbortController();
                const promise = sendRequest(prop.toString(), args, ac.signal);
                abortControllers.set(promise, ac);
                promise
                    .finally(() => {
                    // Remove the
                    abortControllers.delete(promise);
                })
                    .catch(() => { });
                return promise;
            };
        },
    });
}
exports.rpcClient = rpcClient;
/**
 * Create a JsonRpcRequest for the given method.
 */
function createRequest(method, params) {
    return {
        jsonrpc: "2.0",
        id: Date.now(),
        method,
        params: removeTrailingUndefs(params),
    };
}
exports.createRequest = createRequest;
/**
 * Returns a shallow copy the given array without any
 * trailing `undefined` values.
 */
function removeTrailingUndefs(values) {
    const a = [...values];
    while (a.length && a[a.length - 1] === undefined)
        a.length--;
    return a;
}
exports.removeTrailingUndefs = removeTrailingUndefs;
/**
 * Create a RpcTransport that uses the global fetch.
 */
function fetchTransport(options) {
    return async (req, signal) => {
        const headers = options?.getHeaders ? await options.getHeaders() : {};
        const res = await fetch(options.url, {
            method: "POST",
            headers: {
                Accept: "application/json",
                "Content-Type": "application/json",
                ...headers,
            },
            body: JSON.stringify(req),
            credentials: options?.credentials,
            signal,
        });
        if (!res.ok) {
            throw new RpcError(res.statusText, res.status);
        }
        return await res.json();
    };
}
exports.fetchTransport = fetchTransport;
//# sourceMappingURL=client.js.map